# Day 9 - Python 进阶基础学习

本项目记录了 Python 学习第 9 天的代码与笔记，主要涵盖了 **类型判断**、**深拷贝与浅拷贝** 以及 **正则表达式** 的详细用法。

## 📂 文件说明

- `判断类型.py`: 学习如何正确检查变量的数据类型。
- `深copy与浅copy.py`: 深入理解 Python 中对象引用的复制机制。
- `正则表达式.py`: 全面掌握 Python `re` 模块的各种匹配、查找和替换功能。

---

## 1. 类型判断 (`isinstance`)

在 Python 中，推荐使用 `isinstance()` 而不是 `type()` 来检查变量类型，因为它支持继承关系判断。

```python
# 语法
isinstance(object, classinfo)

# 示例
x = 10
isinstance(x, int)  # True
isinstance(x, (str, int))  # True (检查是否为元组中任意一种类型)
```

---

## 2. 深拷贝与浅拷贝 (Deep vs Shallow Copy)

理解对象引用、浅拷贝和深拷贝的区别对于处理可变对象（如列表、字典）至关重要。

| 方式 | 语法 | 描述 |
| :--- | :--- | :--- |
| **赋值** | `b = a` | **引用传递**。`a` 和 `b` 指向同一个对象，修改其中一个会影响另一个。 |
| **浅拷贝** | `b = a.copy()` 或 `copy.copy(a)` | 创建新对象，但**共享内部子对象的引用**。修改外层互不影响，但修改嵌套的可变对象会互相影响。 |
| **深拷贝** | `b = copy.deepcopy(a)` | **完全独立**。递归复制所有层级的对象。修改任何一层都互不影响。 |

---

## 3. 正则表达式 (`re` 模块)

正则表达式用于处理字符串匹配、查找和替换。

### 核心函数

| 函数 | 描述 | 关键点 |
| :--- | :--- | :--- |
| `re.match(pattern, string)` | 从字符串**开头**匹配 | 如果开头不匹配，返回 `None`。 |
| `re.search(pattern, string)` | 扫描**整个**字符串 | 返回**第一个**成功的匹配项。 |
| `re.findall(pattern, string)` | 查找**所有**匹配项 | 返回一个包含所有匹配字符串的**列表**。 |
| `re.finditer(pattern, string)` | 查找**所有**匹配项 | 返回一个**迭代器**，需用 `for` 循环或 `next()` 遍历。 |
| `re.sub(pattern, repl, string)` | 替换匹配的字符串 | 可用 `count` 参数限制替换次数。 |

### 常用元字符

- `.` : 匹配除换行符外的任意字符。
- `\d` : 匹配数字 `[0-9]`。
- `\w` : 匹配单词字符（字母、数字、下划线）。
- `\s` : 匹配空白字符（空格、Tab、换行）。
- `[]` : 字符集合，如 `[a-z]` 匹配小写字母。
- `^` : 在 `[]` 外表示字符串开头；在 `[]` 内表示取反（非）。
- `$` : 匹配字符串结尾。

### 量词与模式

- `*` : 0 次或多次。
- `+` : 1 次或多次。
- `?` : 0 次或 1 次。
- `{n,m}` : n 到 m 次。
- **贪婪匹配** (默认): 尽可能多地匹配字符（如 `.*`）。
- **非贪婪匹配** (`?`): 尽可能少地匹配字符（如 `.*?`）。

### 分组与引用

- `(...)` : 捕获分组，可用 `.group(1)` 获取。
- `(?P<name>...)` : 命名分组，可用 `.group('name')` 获取。
- `\1` : 引用前面的第 1 个分组（常用于匹配成对的 HTML 标签）。

### 示例代码片段

**1. 邮箱验证 (注意转义和锚点)**
```python
# 匹配 163, qq, 126 邮箱
re.match(r"\w{4,20}@(163|qq|126)\.com$", email)
```

**2. 提取数据 (分组)**
```python
# 提取连字符前后的内容
result = re.match(r"([^-]+)-(\d+)", "partA-123")
print(result.group(1)) # partA
print(result.group(2)) # 123
```

**3. 非贪婪匹配**
```python
# 跳过前面任意字符，直到找到符合格式的数字串
re.match(r".+?(\d+)-(\d+)", "text 123-456")
```

---

## 注意事项

1. **原始字符串**: 写正则时建议始终使用 `r"..."` (如 `r"\d"`)，避免 Python 字符串转义与正则转义冲突。
2. **符号中英文**: 编写正则时务必使用英文符号（如 `?`, `()`, `.`），避免使用中文全角符号。
